<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Nano: Class Hierarchy</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Nano
   </div>
   <div id="projectbrief">A C++ template metaprogramming library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li class="current"><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Class Hierarchy</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock">
<p><a href="inherits.html">Go to the graphical class hierarchy</a></p>
This inheritance list is sorted roughly, but not completely, alphabetically:</div><div class="directory">
<div class="levels">[detail level <span onclick="javascript:toggleLevel(1);">1</span><span onclick="javascript:toggleLevel(2);">2</span>]</div><table class="directory">
<tr id="row_0_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1detail_1_1accumulate.html" target="_self">nano::detail::accumulate&lt; List, Iteration, StartIndex, EndIndex, Value, Operation &gt;</a></td><td class="desc">Like std::accumulate, where the start and end indices, and the accumulation functor can be specified </td></tr>
<tr id="row_1_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1detail_1_1accumulate_3_01list_3_01Head_00_01Tail_8_8_8_4_00_01Iteration_00_01Startc5157d13def6a96e40eee4632c6c3590.html" target="_self">nano::detail::accumulate&lt; list&lt; Head, Tail...&gt;, Iteration, StartIndex, EndIndex, Value, Operation &gt;</a></td><td class="desc"></td></tr>
<tr id="row_2_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1detail_1_1accumulate_3_01list_3_01Tail_8_8_8_4_00_01Iteration_00_01StartIndex_00_0c72c58d80d45660b6fb344d6cbf8b980.html" target="_self">nano::detail::accumulate&lt; list&lt; Tail...&gt;, Iteration, StartIndex, EndIndex, Value, Operation &gt;</a></td><td class="desc"></td></tr>
<tr id="row_3_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1add.html" target="_self">nano::add&lt; Arg1, Arg2 &gt;</a></td><td class="desc">Addss two nano numeric types </td></tr>
<tr id="row_4_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1args__list.html" target="_self">nano::args_list&lt; Args &gt;</a></td><td class="desc">A list of arguments </td></tr>
<tr id="row_5_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1detail_1_1array__convert.html" target="_self">nano::detail::array_convert&lt; Element &gt;</a></td><td class="desc">Converts an element to a std type, like <a class="el" href="structnano_1_1int__t.html" title="Wrapper around int for static int types used by metaclass and metafunctions in nano. ">nano::int_t</a> to inr or a <a class="el" href="structnano_1_1list.html" title="Meta class that holds types, and allows functions to be applied to the elements of the list using the...">nano::list</a> into a std::array with N elements </td></tr>
<tr id="row_6_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1detail_1_1array__convert_3_01list_3_01First_00_01Rest_8_8_8_4_01_4.html" target="_self">nano::detail::array_convert&lt; list&lt; First, Rest...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_7_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1both__found.html" target="_self">nano::both_found&lt; Type1, Type2 &gt;</a></td><td class="desc">Checks if both types are found (have values != -1), in which case result is true, otherwise result is false </td></tr>
<tr id="row_8_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1detail_1_1build__range.html" target="_self">nano::detail::build_range&lt; Current, Step, Iteration, Continue, Values &gt;</a></td><td class="desc">Builds a range of <a class="el" href="structnano_1_1int__t.html" title="Wrapper around int for static int types used by metaclass and metafunctions in nano. ">nano::int_t</a> types </td></tr>
<tr id="row_9_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1detail_1_1build__range_3_01Current_00_01Step_00_01Iteration_00_01false_00_01list_311203ace299b2adc7ee30f5975aca7d1.html" target="_self">nano::detail::build_range&lt; Current, Step, Iteration, false, list&lt; nano::int_t&lt; Values &gt;...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_10_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1detail_1_1build__range_3_01Current_00_01Step_00_01Iteration_00_01true_00_01list_3_0b8990ea37172fc6dd6c7e8885a9c80d.html" target="_self">nano::detail::build_range&lt; Current, Step, Iteration, true, list&lt; nano::int_t&lt; Values &gt;...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_11_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1equal__value.html" target="_self">nano::equal_value&lt; Type1, Type2 &gt;</a></td><td class="desc">Check if two types (which have value components) have the same value </td></tr>
<tr id="row_12_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1eval.html" target="_self">nano::eval&lt; Expression, Arg &gt;</a></td><td class="desc">Evaluates an expression with arguments </td></tr>
<tr id="row_13_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1eval_3_01Expression_00_01no__args_01_4.html" target="_self">nano::eval&lt; Expression, no_args &gt;</a></td><td class="desc"></td></tr>
<tr id="row_14_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1eval_3_01Function_3_01Args_8_8_8_4_00_01no__args_01_4.html" target="_self">nano::eval&lt; Function&lt; Args...&gt;, no_args &gt;</a></td><td class="desc"></td></tr>
<tr id="row_15_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1expand.html" target="_self">nano::expand&lt; Expression, Arg, Expandable &gt;</a></td><td class="desc">Expands a list into its types </td></tr>
<tr id="row_16_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1expand_3_01Expression_00_01Arg_00_01false_01_4.html" target="_self">nano::expand&lt; Expression, Arg, false &gt;</a></td><td class="desc"></td></tr>
<tr id="row_17_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1expand_3_01Expression_00_01Arg_00_01true_01_4.html" target="_self">nano::expand&lt; Expression, Arg, true &gt;</a></td><td class="desc"></td></tr>
<tr id="row_18_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1filter.html" target="_self">nano::filter&lt; Evaluator, List1, List2, Passed &gt;</a></td><td class="desc">Takes a list and an evaluation function, which itself takes the list and a parameter to evaluate if each element of the list must be filtered </td></tr>
<tr id="row_19_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1filter_3_01Evaluator_00_01empty__list_00_01list_3_01Tail2_8_8_8_4_00_01list_3_01Passed_8_8_8_4_01_4.html" target="_self">nano::filter&lt; Evaluator, empty_list, list&lt; Tail2...&gt;, list&lt; Passed...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_20_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1filter_3_01Evaluator_00_01list_3_01Head1_00_01Tail1_8_8_8_4_00_01list_3_01Head2_00a5eb6823856bc057df83686a23fa58aa.html" target="_self">nano::filter&lt; Evaluator, list&lt; Head1, Tail1...&gt;, list&lt; Head2, Tail2...&gt;, list&lt; Passed...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_21_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1find__common.html" target="_self">nano::find_common&lt; List1, List2 &gt;</a></td><td class="desc">Finds all common elements in 2 lists and returns a zipped list of the result, where each zipped element is a index of the common element in the lists. The zips are sorted by the index of the element in the first list. For example, if there are 2 lists: <br />
<br />
 [ 0, 4, 2, 1 ] and [ 12, 1, 4, 2 ] <br />
<br />
 the returned list will be: <br />
<br />
 [ [1, 2], [2 ,3], [1, 2] ] </td></tr>
<tr id="row_22_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1find__common_3_01list_3_01Head1_00_01Tail1_8_8_8_4_00_01list_3_01Head2_00_01Tail2_8_8_8_4_01_4.html" target="_self">nano::find_common&lt; list&lt; Head1, Tail1...&gt;, list&lt; Head2, Tail2...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_23_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1find__type.html" target="_self">nano::find_type&lt; Type, List &gt;</a></td><td class="desc">Find the index of a specific type in the list (the index of the first occurrence). <br />
 If the type is not found then the value 'parameter' will be -1 </td></tr>
<tr id="row_24_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1find__type_3_01Type_00_01list_3_01Head_00_01Tail_8_8_8_4_01_4.html" target="_self">nano::find_type&lt; Type, list&lt; Head, Tail...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_25_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1find__type_3_01Type_00_01list_3_01Type_00_01Tail_8_8_8_4_01_4.html" target="_self">nano::find_type&lt; Type, list&lt; Type, Tail...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_26_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1find__type_3_01Type_00_01list_3_4_01_4.html" target="_self">nano::find_type&lt; Type, list&lt;&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_27_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1find__uncommon.html" target="_self">nano::find_uncommon&lt; List1, List2 &gt;</a></td><td class="desc">Finds all elements of the first list which are not present in the second list, and returns a new list without the common elements. For example, if there are 2 lists: <br />
<br />
 [ 2, 3, 1, 4 ] and [ 4, 5, 2 ] <br />
<br />
 the returned list will be: <br />
<br />
 [ 3, 1 ] </td></tr>
<tr id="row_28_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1find__uncommon_3_01list_3_01Head1_00_01Tail1_8_8_8_4_00_01list_3_01Head2_00_01Tail2_8_8_8_4_01_4.html" target="_self">nano::find_uncommon&lt; list&lt; Head1, Tail1...&gt;, list&lt; Head2, Tail2...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_29_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1find__uncommon__indices.html" target="_self">nano::find_uncommon_indices&lt; List1, List2 &gt;</a></td><td class="desc">Finds the indices of the elements in the first list which are not present in the second list and returns a list of the index values. For example, if there are 2 lists: <br />
<br />
 [ 2, 3, 1, 4 ] and [ 4, 5, 2 ] <br />
<br />
 the returned list will be: <br />
<br />
 [ 1, 3 ] </td></tr>
<tr id="row_30_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1find__uncommon__indices_3_01list_3_01Head1_00_01Tail1_8_8_8_4_00_01list_3_01Head2_00_01Tail2_8_8_8_4_01_4.html" target="_self">nano::find_uncommon_indices&lt; list&lt; Head1, Tail1...&gt;, list&lt; Head2, Tail2...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_31_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1first__not__present.html" target="_self">nano::first_not_present&lt; Type, List &gt;</a></td><td class="desc">Just check if the first element of the list was found (searching should be done beforehand) </td></tr>
<tr id="row_32_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1first__not__present_3_01Type_00_01list_3_01Head_00_01Tail_8_8_8_4_01_4.html" target="_self">nano::first_not_present&lt; Type, list&lt; Head, Tail...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_33_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1detail_1_1get.html" target="_self">nano::detail::get&lt; Index, List &gt;</a></td><td class="desc">Meta function to get an element from a list </td></tr>
<tr id="row_34_" class="even"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_34_" class="arrow" onclick="toggleFolder('34_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1detail_1_1get.html" target="_self">nano::detail::get&lt; nano::size_t&lt; Index-1 &gt;, list&lt; Tail...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_34_0_"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1detail_1_1get_3_01nano_1_1size__t_3_01Index_01_4_00_01list_3_01Head_00_01Tail_8_8_8_4_01_4.html" target="_self">nano::detail::get&lt; nano::size_t&lt; Index &gt;, list&lt; Head, Tail...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_35_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1identify.html" target="_self">nano::identify&lt; Type &gt;</a></td><td class="desc">Simply an identifier to identify meta types and meta functions </td></tr>
<tr id="row_36_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_36_" class="arrow" onclick="toggleFolder('36_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1identify.html" target="_self">nano::identify&lt; Head &gt;</a></td><td class="desc"></td></tr>
<tr id="row_36_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1detail_1_1get_3_01nano_1_1size__t_3_010_01_4_00_01list_3_01Head_00_01Tail_8_8_8_4_01_4.html" target="_self">nano::detail::get&lt; nano::size_t&lt; 0 &gt;, list&lt; Head, Tail...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_37_"><td class="entry"><span style="width:0px;display:inline-block;">&#160;</span><span id="arr_37_" class="arrow" onclick="toggleFolder('37_')">&#9660;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1identify.html" target="_self">nano::identify&lt; list&lt; Ts..., Us...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_37_0_" class="even"><td class="entry"><span style="width:32px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1join_3_01list_3_01Ts_8_8_8_4_00_01list_3_01Us_8_8_8_4_01_4.html" target="_self">nano::join&lt; list&lt; Ts...&gt;, list&lt; Us...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_38_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1int__t.html" target="_self">nano::int_t&lt; Value &gt;</a></td><td class="desc">Wrapper around int for static int types used by metaclass and metafunctions in nano </td></tr>
<tr id="row_39_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1is__found.html" target="_self">nano::is_found&lt; Type1, Type2 &gt;</a></td><td class="desc">Ths function is supposed to be used with the find functions on lists when searching through the list to find common or uncommon elements. It should be called by the zip HOF to determine if Type1 and Type2 should be zipped and added to the list of elements to return. <br />
<br />
 Please see the implementation of the <a class="el" href="structnano_1_1find__common.html" title="Finds all common elements in 2 lists and returns a zipped list of the result, where each zipped eleme...">find_common</a> and zip functions for clarificaiton </td></tr>
<tr id="row_40_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1join.html" target="_self">nano::join&lt; List1, List2 &gt;</a></td><td class="desc">Joins two lists </td></tr>
<tr id="row_41_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1list.html" target="_self">nano::list&lt; Ts &gt;</a></td><td class="desc">Meta class that holds types, and allows functions to be applied to the elements of the list using the internal apply struct. <br />
 <br />
 Usage: <br />
 <br />
 using nano::dim; \ To get dimension types <br />
 using test_list = list&lt;i, j, k, l&gt;; \ A list of dimensions <br />
 <br />
 using shifted_list = list::apply&lt;shift&gt;; <br />
 <br />
 Where shift is some function which operates on a type in the list </td></tr>
<tr id="row_42_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1multiplies.html" target="_self">nano::multiplies&lt; List, Current &gt;</a></td><td class="desc">Same as std::multiplies, but for a nano:list which can be computed at compile time - computes the product of the list elelents from the starting value </td></tr>
<tr id="row_43_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1multiplies_3_01empty__list_00_01Current_01_4.html" target="_self">nano::multiplies&lt; empty_list, Current &gt;</a></td><td class="desc"></td></tr>
<tr id="row_44_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1multiplies_3_01list_3_01Head_00_01Tail_8_8_8_4_00_01Current_01_4.html" target="_self">nano::multiplies&lt; list&lt; Head, Tail...&gt;, Current &gt;</a></td><td class="desc"></td></tr>
<tr id="row_45_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1multiply.html" target="_self">nano::multiply&lt; Arg1, Arg2 &gt;</a></td><td class="desc">Multiplies two nano numeric types </td></tr>
<tr id="row_46_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1not__found.html" target="_self">nano::not_found&lt; Type &gt;</a></td><td class="desc">Function to determine if and element is not found (has a value of -1) </td></tr>
<tr id="row_47_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1pair.html" target="_self">nano::pair&lt; First, Second &gt;</a></td><td class="desc">Holds two elements </td></tr>
<tr id="row_48_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1range.html" target="_self">nano::range&lt; Start, End, Step &gt;</a></td><td class="desc">Constructs a range of <a class="el" href="structnano_1_1int__t.html" title="Wrapper around int for static int types used by metaclass and metafunctions in nano. ">nano::int_t</a> t types, which is essentially just a list of <a class="el" href="structnano_1_1int__t.html" title="Wrapper around int for static int types used by metaclass and metafunctions in nano. ">nano::int_t</a> types </td></tr>
<tr id="row_49_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1runtime__converter.html" target="_self">nano::runtime_converter&lt; List &gt;</a></td><td class="desc">Wrapper class to provide the conversion functions for converting to runtime containers </td></tr>
<tr id="row_50_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1runtime__converter_3_01list_3_01Head_00_01Tail_8_8_8_4_01_4.html" target="_self">nano::runtime_converter&lt; list&lt; Head, Tail...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_51_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1detail_1_1search__lists.html" target="_self">nano::detail::search_lists&lt; List1, List2 &gt;</a></td><td class="desc">For each element in the first list, the index of the element in the second list is searched for, if found it's added to a new list, otherwise -1 is added </td></tr>
<tr id="row_52_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1detail_1_1search__lists_3_01list_3_01Head1_00_01Tail1_8_8_8_4_00_01list_3_01Head2_00_01Tail2_8_8_8_4_01_4.html" target="_self">nano::detail::search_lists&lt; list&lt; Head1, Tail1...&gt;, list&lt; Head2, Tail2...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_53_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1size__of.html" target="_self">nano::size_of&lt; Container, Types &gt;</a></td><td class="desc">Gets the number of types in a container </td></tr>
<tr id="row_54_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1size__of_3_01Container_3_01Types_8_8_8_4_01_4.html" target="_self">nano::size_of&lt; Container&lt; Types...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_55_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1size__t.html" target="_self">nano::size_t&lt; Value &gt;</a></td><td class="desc">Wrapper around <a class="el" href="structnano_1_1size__t.html" title="Wrapper around size_t for static size_t types used by metaclass and metafunctions in nano...">size_t</a> for static <a class="el" href="structnano_1_1size__t.html" title="Wrapper around size_t for static size_t types used by metaclass and metafunctions in nano...">size_t</a> types used by metaclass and metafunctions in nano </td></tr>
<tr id="row_56_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1type__not__present.html" target="_self">nano::type_not_present&lt; Type, List &gt;</a></td><td class="desc">To check if a type in a list is not found. Where the <a class="el" href="structnano_1_1find__type.html" title="Find the index of a specific type in the list (the index of the first occurrence).   If the type is not found then the value &#39;parameter&#39; will be -1. ">find_type</a> tries to find a type and get its index to return, this function simply returns true of the type is not found, and false if the tpe is found </td></tr>
<tr id="row_57_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1type__not__present_3_01Type_00_01list_3_01Head_00_01Tail_8_8_8_4_01_4.html" target="_self">nano::type_not_present&lt; Type, list&lt; Head, Tail...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_58_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1type__not__present_3_01Type_00_01list_3_01Type_00_01Tail_8_8_8_4_01_4.html" target="_self">nano::type_not_present&lt; Type, list&lt; Type, Tail...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_59_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1type__not__present_3_01Type_00_01list_3_4_01_4.html" target="_self">nano::type_not_present&lt; Type, list&lt;&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_60_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1detail_1_1vector__convert.html" target="_self">nano::detail::vector_convert&lt; Element &gt;</a></td><td class="desc">Same as convert, but uses vector's instead of arrays, so the performance is worse </td></tr>
<tr id="row_61_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1detail_1_1vector__convert_3_01list_3_01First_00_01Rest_8_8_8_4_01_4.html" target="_self">nano::detail::vector_convert&lt; list&lt; First, Rest...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_62_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1zip.html" target="_self">nano::zip&lt; Evaluator, List1, List2, Passed &gt;</a></td><td class="desc">Takes two lists, and zips the corresponding elements into a list of 2 elements if the function to determine if the elements should be zips succeeds, otherwise the elements are not zipped </td></tr>
<tr id="row_63_" class="even"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1zip_3_01Evaluator_00_01empty__list_00_01empty__list_00_01list_3_01Passed_8_8_8_4_01_4.html" target="_self">nano::zip&lt; Evaluator, empty_list, empty_list, list&lt; Passed...&gt; &gt;</a></td><td class="desc"></td></tr>
<tr id="row_64_"><td class="entry"><span style="width:16px;display:inline-block;">&#160;</span><span class="icona"><span class="icon">C</span></span><a class="el" href="structnano_1_1zip_3_01Evaluator_00_01list_3_01Head1_00_01Tail1_8_8_8_4_00_01list_3_01Head2_00_01473f73c22a17069f7ee2ba2934a151a5.html" target="_self">nano::zip&lt; Evaluator, list&lt; Head1, Tail1...&gt;, list&lt; Head2, Tail2...&gt;, list&lt; Passed...&gt; &gt;</a></td><td class="desc"></td></tr>
</table>
</div><!-- directory -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 23 2015 14:09:32 for Nano by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
