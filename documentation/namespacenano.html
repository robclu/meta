<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Nano: nano Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Nano
   </div>
   <div id="projectbrief">A C++ template metaprogramming library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">nano Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacenano_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenano_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1add.html">add</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addss two nano numeric types.  <a href="structnano_1_1add.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1args__list.html">args_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of arguments.  <a href="structnano_1_1args__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1both__found.html">both_found</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if both types are found (have values != -1), in which case result is true, otherwise result is false.  <a href="structnano_1_1both__found.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1equal__value.html">equal_value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two types (which have value components) have the same value.  <a href="structnano_1_1equal__value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1eval.html">eval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates an expression with arguments.  <a href="structnano_1_1eval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1eval_3_01Expression_00_01no__args_01_4.html">eval&lt; Expression, no_args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1eval_3_01Function_3_01Args_8_8_8_4_00_01no__args_01_4.html">eval&lt; Function&lt; Args...&gt;, no_args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1expand.html">expand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands a list into its types.  <a href="structnano_1_1expand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1expand_3_01Expression_00_01Arg_00_01false_01_4.html">expand&lt; Expression, Arg, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1expand_3_01Expression_00_01Arg_00_01true_01_4.html">expand&lt; Expression, Arg, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1filter.html">filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a list and an evaluation function, which itself takes the list and a parameter to evaluate if each element of the list must be filtered.  <a href="structnano_1_1filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1filter_3_01Evaluator_00_01empty__list_00_01list_3_01Tail2_8_8_8_4_00_01list_3_01Passed_8_8_8_4_01_4.html">filter&lt; Evaluator, empty_list, list&lt; Tail2...&gt;, list&lt; Passed...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1filter_3_01Evaluator_00_01list_3_01Head1_00_01Tail1_8_8_8_4_00_01list_3_01Head2_00a5eb6823856bc057df83686a23fa58aa.html">filter&lt; Evaluator, list&lt; Head1, Tail1...&gt;, list&lt; Head2, Tail2...&gt;, list&lt; Passed...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1find__common.html">find_common</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all common elements in 2 lists and returns a zipped list of the result, where each zipped element is a index of the common element in the lists. The zips are sorted by the index of the element in the first list. For example, if there are 2 lists: <br />
<br />
 [ 0, 4, 2, 1 ] and [ 12, 1, 4, 2 ] <br />
<br />
 the returned list will be: <br />
<br />
 [ [1, 2], [2 ,3], [1, 2] ].  <a href="structnano_1_1find__common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1find__common_3_01list_3_01Head1_00_01Tail1_8_8_8_4_00_01list_3_01Head2_00_01Tail2_8_8_8_4_01_4.html">find_common&lt; list&lt; Head1, Tail1...&gt;, list&lt; Head2, Tail2...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1find__type.html">find_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of a specific type in the list (the index of the first occurrence). <br />
 If the type is not found then the value 'parameter' will be -1.  <a href="structnano_1_1find__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1find__type_3_01Type_00_01list_3_01Head_00_01Tail_8_8_8_4_01_4.html">find_type&lt; Type, list&lt; Head, Tail...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1find__type_3_01Type_00_01list_3_01Type_00_01Tail_8_8_8_4_01_4.html">find_type&lt; Type, list&lt; Type, Tail...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1find__type_3_01Type_00_01list_3_4_01_4.html">find_type&lt; Type, list&lt;&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1find__uncommon.html">find_uncommon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all elements of the first list which are not present in the second list, and returns a new list without the common elements. For example, if there are 2 lists: <br />
<br />
 [ 2, 3, 1, 4 ] and [ 4, 5, 2 ] <br />
<br />
 the returned list will be: <br />
<br />
 [ 3, 1 ].  <a href="structnano_1_1find__uncommon.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1find__uncommon_3_01list_3_01Head1_00_01Tail1_8_8_8_4_00_01list_3_01Head2_00_01Tail2_8_8_8_4_01_4.html">find_uncommon&lt; list&lt; Head1, Tail1...&gt;, list&lt; Head2, Tail2...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1find__uncommon__indices.html">find_uncommon_indices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the indices of the elements in the first list which are not present in the second list and returns a list of the index values. For example, if there are 2 lists: <br />
<br />
 [ 2, 3, 1, 4 ] and [ 4, 5, 2 ] <br />
<br />
 the returned list will be: <br />
<br />
 [ 1, 3 ].  <a href="structnano_1_1find__uncommon__indices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1find__uncommon__indices_3_01list_3_01Head1_00_01Tail1_8_8_8_4_00_01list_3_01Head2_00_01Tail2_8_8_8_4_01_4.html">find_uncommon_indices&lt; list&lt; Head1, Tail1...&gt;, list&lt; Head2, Tail2...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1first__not__present.html">first_not_present</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just check if the first element of the list was found (searching should be done beforehand)  <a href="structnano_1_1first__not__present.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1first__not__present_3_01Type_00_01list_3_01Head_00_01Tail_8_8_8_4_01_4.html">first_not_present&lt; Type, list&lt; Head, Tail...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1identify.html">identify</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simply an identifier to identify meta types and meta functions.  <a href="structnano_1_1identify.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1int__t.html">int_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around int for static int types used by metaclass and metafunctions in nano.  <a href="structnano_1_1int__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1is__found.html">is_found</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ths function is supposed to be used with the find functions on lists when searching through the list to find common or uncommon elements. It should be called by the zip HOF to determine if Type1 and Type2 should be zipped and added to the list of elements to return. <br />
<br />
 Please see the implementation of the <a class="el" href="structnano_1_1find__common.html" title="Finds all common elements in 2 lists and returns a zipped list of the result, where each zipped eleme...">find_common</a> and zip functions for clarificaiton.  <a href="structnano_1_1is__found.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1join.html">join</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins two lists.  <a href="structnano_1_1join.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1join_3_01list_3_01Ts_8_8_8_4_00_01list_3_01Us_8_8_8_4_01_4.html">join&lt; list&lt; Ts...&gt;, list&lt; Us...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1list.html">list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta class that holds types, and allows functions to be applied to the elements of the list using the internal apply struct. <br />
 <br />
 Usage: <br />
 <br />
 using nano::dim; \ To get dimension types <br />
 using test_list = list&lt;i, j, k, l&gt;; \ A list of dimensions <br />
 <br />
 using shifted_list = list::apply&lt;shift&gt;; <br />
 <br />
 Where shift is some function which operates on a type in the list.  <a href="structnano_1_1list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1multiplies.html">multiplies</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as std::multiplies, but for a nano:list which can be computed at compile time - computes the product of the list elelents from the starting value.  <a href="structnano_1_1multiplies.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1multiplies_3_01empty__list_00_01Current_01_4.html">multiplies&lt; empty_list, Current &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1multiplies_3_01list_3_01Head_00_01Tail_8_8_8_4_00_01Current_01_4.html">multiplies&lt; list&lt; Head, Tail...&gt;, Current &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1multiply.html">multiply</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies two nano numeric types.  <a href="structnano_1_1multiply.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1not__found.html">not_found</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to determine if and element is not found (has a value of -1)  <a href="structnano_1_1not__found.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1pair.html">pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds two elements.  <a href="structnano_1_1pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1range.html">range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a range of <a class="el" href="structnano_1_1int__t.html" title="Wrapper around int for static int types used by metaclass and metafunctions in nano. ">nano::int_t</a> t types, which is essentially just a list of <a class="el" href="structnano_1_1int__t.html" title="Wrapper around int for static int types used by metaclass and metafunctions in nano. ">nano::int_t</a> types.  <a href="structnano_1_1range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1runtime__converter.html">runtime_converter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class to provide the conversion functions for converting to runtime containers.  <a href="structnano_1_1runtime__converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1runtime__converter_3_01list_3_01Head_00_01Tail_8_8_8_4_01_4.html">runtime_converter&lt; list&lt; Head, Tail...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1size__of.html">size_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of types in a container.  <a href="structnano_1_1size__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1size__of_3_01Container_3_01Types_8_8_8_4_01_4.html">size_of&lt; Container&lt; Types...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1size__t.html">size_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around <a class="el" href="structnano_1_1size__t.html" title="Wrapper around size_t for static size_t types used by metaclass and metafunctions in nano...">size_t</a> for static <a class="el" href="structnano_1_1size__t.html" title="Wrapper around size_t for static size_t types used by metaclass and metafunctions in nano...">size_t</a> types used by metaclass and metafunctions in nano.  <a href="structnano_1_1size__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1type__not__present.html">type_not_present</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">To check if a type in a list is not found. Where the <a class="el" href="structnano_1_1find__type.html" title="Find the index of a specific type in the list (the index of the first occurrence).   If the type is not found then the value &#39;parameter&#39; will be -1. ">find_type</a> tries to find a type and get its index to return, this function simply returns true of the type is not found, and false if the tpe is found.  <a href="structnano_1_1type__not__present.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1type__not__present_3_01Type_00_01list_3_01Head_00_01Tail_8_8_8_4_01_4.html">type_not_present&lt; Type, list&lt; Head, Tail...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1type__not__present_3_01Type_00_01list_3_01Type_00_01Tail_8_8_8_4_01_4.html">type_not_present&lt; Type, list&lt; Type, Tail...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1type__not__present_3_01Type_00_01list_3_4_01_4.html">type_not_present&lt; Type, list&lt;&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1zip.html">zip</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes two lists, and zips the corresponding elements into a list of 2 elements if the function to determine if the elements should be zips succeeds, otherwise the elements are not zipped.  <a href="structnano_1_1zip.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1zip_3_01Evaluator_00_01empty__list_00_01empty__list_00_01list_3_01Passed_8_8_8_4_01_4.html">zip&lt; Evaluator, empty_list, empty_list, list&lt; Passed...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnano_1_1zip_3_01Evaluator_00_01list_3_01Head1_00_01Tail1_8_8_8_4_00_01list_3_01Head2_00_01473f73c22a17069f7ee2ba2934a151a5.html">zip&lt; Evaluator, list&lt; Head1, Tail1...&gt;, list&lt; Head2, Tail2...&gt;, list&lt; Passed...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4262db6dd96f202d3dd24469a5c65230"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenano.html#a4262db6dd96f202d3dd24469a5c65230">no_args</a> = <a class="el" href="structnano_1_1args__list.html">args_list</a>&lt;&gt;</td></tr>
<tr class="separator:a4262db6dd96f202d3dd24469a5c65230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e95fbfeea3f49c6c41ce4fa4063628d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenano.html#a4e95fbfeea3f49c6c41ce4fa4063628d">empty_list</a> = <a class="el" href="structnano_1_1list.html">list</a>&lt;&gt;</td></tr>
<tr class="separator:a4e95fbfeea3f49c6c41ce4fa4063628d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a636aa41ba1cc15f45a619a7592c45"><td class="memTemplParams" colspan="2">template&lt;std::size_t Index, typename List &gt; </td></tr>
<tr class="memitem:a55a636aa41ba1cc15f45a619a7592c45"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenano.html#a55a636aa41ba1cc15f45a619a7592c45">get</a> = typename <a class="el" href="structnano_1_1detail_1_1get.html">detail::get</a>&lt; <a class="el" href="structnano_1_1size__t.html">nano::size_t</a>&lt; Index &gt;, List &gt;::result</td></tr>
<tr class="separator:a55a636aa41ba1cc15f45a619a7592c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7024c50691ea36d324357cc515ea4919"><td class="memTemplParams" colspan="2">template&lt;typename List , std::size_t StartIndex = 0, std::size_t EndIndex = std::numeric_limits&lt;std::size_t&gt;::max(), std::size_t StartValue = 1, template&lt; typename...&gt; class Operation = nano::multiply&gt; </td></tr>
<tr class="memitem:a7024c50691ea36d324357cc515ea4919"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacenano.html#a7024c50691ea36d324357cc515ea4919">accumulate</a> = <a class="el" href="structnano_1_1detail_1_1accumulate.html">detail::accumulate</a>&lt; List, 0, <a class="el" href="structnano_1_1size__t.html">nano::size_t</a>&lt; StartIndex &gt;, <a class="el" href="structnano_1_1size__t.html">nano::size_t</a>&lt; EndIndex &gt;, <a class="el" href="structnano_1_1size__t.html">nano::size_t</a>&lt; StartValue &gt;, Operation &gt;</td></tr>
<tr class="separator:a7024c50691ea36d324357cc515ea4919"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a7024c50691ea36d324357cc515ea4919"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename List , std::size_t StartIndex = 0, std::size_t EndIndex = std::numeric_limits&lt;std::size_t&gt;::max(), std::size_t StartValue = 1, template&lt; typename...&gt; class Operation = nano::multiply&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenano.html#a7024c50691ea36d324357cc515ea4919">nano::accumulate</a> = typedef <a class="el" href="structnano_1_1detail_1_1accumulate.html">detail::accumulate</a>&lt;List , 0 , <a class="el" href="structnano_1_1size__t.html">nano::size_t</a>&lt;StartIndex&gt; , <a class="el" href="structnano_1_1size__t.html">nano::size_t</a>&lt;EndIndex&gt; , <a class="el" href="structnano_1_1size__t.html">nano::size_t</a>&lt;StartValue&gt; , Operation &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4e95fbfeea3f49c6c41ce4fa4063628d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenano.html#a4e95fbfeea3f49c6c41ce4fa4063628d">nano::empty_list</a> = typedef <a class="el" href="structnano_1_1list.html">list</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a55a636aa41ba1cc15f45a619a7592c45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Index, typename List &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenano.html#a55a636aa41ba1cc15f45a619a7592c45">nano::get</a> = typedef typename <a class="el" href="structnano_1_1detail_1_1get.html">detail::get</a>&lt;<a class="el" href="structnano_1_1size__t.html">nano::size_t</a>&lt;Index&gt;, List&gt;::result</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4262db6dd96f202d3dd24469a5c65230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacenano.html#a4262db6dd96f202d3dd24469a5c65230">nano::no_args</a> = typedef <a class="el" href="structnano_1_1args__list.html">args_list</a>&lt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 23 2015 14:09:32 for Nano by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
